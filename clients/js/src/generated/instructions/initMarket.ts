/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	addDecoderSizePrefix,
	addEncoderSizePrefix,
	combineCodec,
	fixDecoderSize,
	fixEncoderSize,
	getAddressEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getI64Decoder,
	getI64Encoder,
	getProgramDerivedAddress,
	getStructDecoder,
	getStructEncoder,
	getU32Decoder,
	getU32Encoder,
	getU64Decoder,
	getU64Encoder,
	getUtf8Decoder,
	getUtf8Encoder,
	transformEncoder,
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	type Codec,
	type Decoder,
	type Encoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyAccount,
	type ReadonlyUint8Array,
	type TransactionSigner,
	type WritableAccount,
	type WritableSignerAccount,
} from '@solana/kit';
import { PYTHIA_OP_PROGRAM_ADDRESS } from '../programs';
import { expectAddress, expectSome, getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const INIT_MARKET_DISCRIMINATOR = new Uint8Array([33, 253, 15, 116, 89, 25, 127, 236]);

export function getInitMarketDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_MARKET_DISCRIMINATOR);
}

export type InitMarketInstruction<
	TProgram extends string = typeof PYTHIA_OP_PROGRAM_ADDRESS,
	TAccountSponsor extends string | AccountMeta<string> = string,
	TAccountSponsorAccount extends string | AccountMeta<string> = string,
	TAccountMarket extends string | AccountMeta<string> = string,
	TAccountSystemProgram extends string | AccountMeta<string> = '11111111111111111111111111111111',
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountSponsor extends string
				? WritableSignerAccount<TAccountSponsor> & AccountSignerMeta<TAccountSponsor>
				: TAccountSponsor,
			TAccountSponsorAccount extends string
				? WritableAccount<TAccountSponsorAccount>
				: TAccountSponsorAccount,
			TAccountMarket extends string ? WritableAccount<TAccountMarket> : TAccountMarket,
			TAccountSystemProgram extends string
				? ReadonlyAccount<TAccountSystemProgram>
				: TAccountSystemProgram,
			...TRemainingAccounts,
		]
	>;

export type InitMarketInstructionData = {
	discriminator: ReadonlyUint8Array;
	question: string;
	resolutionDate: bigint;
	liquidityCap: bigint;
	initialLiquidityUsdc: bigint;
	oppWindowDuration: bigint;
	pubWindowDuration: bigint;
};

export type InitMarketInstructionDataArgs = {
	question: string;
	resolutionDate: number | bigint;
	liquidityCap: number | bigint;
	initialLiquidityUsdc: number | bigint;
	oppWindowDuration: number | bigint;
	pubWindowDuration: number | bigint;
};

export function getInitMarketInstructionDataEncoder(): Encoder<InitMarketInstructionDataArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['question', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
			['resolutionDate', getI64Encoder()],
			['liquidityCap', getU64Encoder()],
			['initialLiquidityUsdc', getU64Encoder()],
			['oppWindowDuration', getU64Encoder()],
			['pubWindowDuration', getU64Encoder()],
		]),
		(value) => ({ ...value, discriminator: INIT_MARKET_DISCRIMINATOR }),
	);
}

export function getInitMarketInstructionDataDecoder(): Decoder<InitMarketInstructionData> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['question', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
		['resolutionDate', getI64Decoder()],
		['liquidityCap', getU64Decoder()],
		['initialLiquidityUsdc', getU64Decoder()],
		['oppWindowDuration', getU64Decoder()],
		['pubWindowDuration', getU64Decoder()],
	]);
}

export function getInitMarketInstructionDataCodec(): Codec<
	InitMarketInstructionDataArgs,
	InitMarketInstructionData
> {
	return combineCodec(
		getInitMarketInstructionDataEncoder(),
		getInitMarketInstructionDataDecoder(),
	);
}

export type InitMarketAsyncInput<
	TAccountSponsor extends string = string,
	TAccountSponsorAccount extends string = string,
	TAccountMarket extends string = string,
	TAccountSystemProgram extends string = string,
> = {
	sponsor: TransactionSigner<TAccountSponsor>;
	sponsorAccount: Address<TAccountSponsorAccount>;
	market?: Address<TAccountMarket>;
	systemProgram?: Address<TAccountSystemProgram>;
	question: InitMarketInstructionDataArgs['question'];
	resolutionDate: InitMarketInstructionDataArgs['resolutionDate'];
	liquidityCap: InitMarketInstructionDataArgs['liquidityCap'];
	initialLiquidityUsdc: InitMarketInstructionDataArgs['initialLiquidityUsdc'];
	oppWindowDuration: InitMarketInstructionDataArgs['oppWindowDuration'];
	pubWindowDuration: InitMarketInstructionDataArgs['pubWindowDuration'];
};

export async function getInitMarketInstructionAsync<
	TAccountSponsor extends string,
	TAccountSponsorAccount extends string,
	TAccountMarket extends string,
	TAccountSystemProgram extends string,
	TProgramAddress extends Address = typeof PYTHIA_OP_PROGRAM_ADDRESS,
>(
	input: InitMarketAsyncInput<
		TAccountSponsor,
		TAccountSponsorAccount,
		TAccountMarket,
		TAccountSystemProgram
	>,
	config?: { programAddress?: TProgramAddress },
): Promise<
	InitMarketInstruction<
		TProgramAddress,
		TAccountSponsor,
		TAccountSponsorAccount,
		TAccountMarket,
		TAccountSystemProgram
	>
> {
	// Program address.
	const programAddress = config?.programAddress ?? PYTHIA_OP_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		sponsor: { value: input.sponsor ?? null, isWritable: true },
		sponsorAccount: { value: input.sponsorAccount ?? null, isWritable: true },
		market: { value: input.market ?? null, isWritable: true },
		systemProgram: { value: input.systemProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.market.value) {
		accounts.market.value = await getProgramDerivedAddress({
			programAddress,
			seeds: [
				getBytesEncoder().encode(new Uint8Array([109, 97, 114, 107, 101, 116])),
				getAddressEncoder().encode(expectAddress(accounts.sponsorAccount.value)),
				addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()).encode(
					expectSome(args.question),
				),
			],
		});
	}
	if (!accounts.systemProgram.value) {
		accounts.systemProgram.value =
			'11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.sponsor),
			getAccountMeta(accounts.sponsorAccount),
			getAccountMeta(accounts.market),
			getAccountMeta(accounts.systemProgram),
		],
		data: getInitMarketInstructionDataEncoder().encode(args as InitMarketInstructionDataArgs),
		programAddress,
	} as InitMarketInstruction<TProgramAddress, TAccountSponsor, TAccountSponsorAccount, TAccountMarket, TAccountSystemProgram>);
}

export type InitMarketInput<
	TAccountSponsor extends string = string,
	TAccountSponsorAccount extends string = string,
	TAccountMarket extends string = string,
	TAccountSystemProgram extends string = string,
> = {
	sponsor: TransactionSigner<TAccountSponsor>;
	sponsorAccount: Address<TAccountSponsorAccount>;
	market: Address<TAccountMarket>;
	systemProgram?: Address<TAccountSystemProgram>;
	question: InitMarketInstructionDataArgs['question'];
	resolutionDate: InitMarketInstructionDataArgs['resolutionDate'];
	liquidityCap: InitMarketInstructionDataArgs['liquidityCap'];
	initialLiquidityUsdc: InitMarketInstructionDataArgs['initialLiquidityUsdc'];
	oppWindowDuration: InitMarketInstructionDataArgs['oppWindowDuration'];
	pubWindowDuration: InitMarketInstructionDataArgs['pubWindowDuration'];
};

export function getInitMarketInstruction<
	TAccountSponsor extends string,
	TAccountSponsorAccount extends string,
	TAccountMarket extends string,
	TAccountSystemProgram extends string,
	TProgramAddress extends Address = typeof PYTHIA_OP_PROGRAM_ADDRESS,
>(
	input: InitMarketInput<
		TAccountSponsor,
		TAccountSponsorAccount,
		TAccountMarket,
		TAccountSystemProgram
	>,
	config?: { programAddress?: TProgramAddress },
): InitMarketInstruction<
	TProgramAddress,
	TAccountSponsor,
	TAccountSponsorAccount,
	TAccountMarket,
	TAccountSystemProgram
> {
	// Program address.
	const programAddress = config?.programAddress ?? PYTHIA_OP_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		sponsor: { value: input.sponsor ?? null, isWritable: true },
		sponsorAccount: { value: input.sponsorAccount ?? null, isWritable: true },
		market: { value: input.market ?? null, isWritable: true },
		systemProgram: { value: input.systemProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.systemProgram.value) {
		accounts.systemProgram.value =
			'11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
	return Object.freeze({
		accounts: [
			getAccountMeta(accounts.sponsor),
			getAccountMeta(accounts.sponsorAccount),
			getAccountMeta(accounts.market),
			getAccountMeta(accounts.systemProgram),
		],
		data: getInitMarketInstructionDataEncoder().encode(args as InitMarketInstructionDataArgs),
		programAddress,
	} as InitMarketInstruction<TProgramAddress, TAccountSponsor, TAccountSponsorAccount, TAccountMarket, TAccountSystemProgram>);
}

export type ParsedInitMarketInstruction<
	TProgram extends string = typeof PYTHIA_OP_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		sponsor: TAccountMetas[0];
		sponsorAccount: TAccountMetas[1];
		market: TAccountMetas[2];
		systemProgram: TAccountMetas[3];
	};
	data: InitMarketInstructionData;
};

export function parseInitMarketInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>,
): ParsedInitMarketInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 4) {
		// TODO: Coded error.
		throw new Error('Not enough accounts');
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: {
			sponsor: getNextAccount(),
			sponsorAccount: getNextAccount(),
			market: getNextAccount(),
			systemProgram: getNextAccount(),
		},
		data: getInitMarketInstructionDataDecoder().decode(instruction.data),
	};
}
