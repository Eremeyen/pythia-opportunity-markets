/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	combineCodec,
	fixDecoderSize,
	fixEncoderSize,
	getBooleanDecoder,
	getBooleanEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	getU64Decoder,
	getU64Encoder,
	transformEncoder,
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyUint8Array,
	type TransactionSigner,
	type WritableAccount,
	type WritableSignerAccount,
} from '@solana/kit';
import { PYTHIA_OP_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const TRADE_PUBLIC_DISCRIMINATOR = new Uint8Array([97, 166, 114, 209, 51, 136, 133, 98]);

export function getTradePublicDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(TRADE_PUBLIC_DISCRIMINATOR);
}

export type TradePublicInstruction<
	TProgram extends string = typeof PYTHIA_OP_PROGRAM_ADDRESS,
	TAccountTrader extends string | AccountMeta<string> = string,
	TAccountMarket extends string | AccountMeta<string> = string,
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountTrader extends string
				? WritableSignerAccount<TAccountTrader> & AccountSignerMeta<TAccountTrader>
				: TAccountTrader,
			TAccountMarket extends string ? WritableAccount<TAccountMarket> : TAccountMarket,
			...TRemainingAccounts,
		]
	>;

export type TradePublicInstructionData = {
	discriminator: ReadonlyUint8Array;
	usdcAmount: bigint;
	isBuyYes: boolean;
};

export type TradePublicInstructionDataArgs = {
	usdcAmount: number | bigint;
	isBuyYes: boolean;
};

export function getTradePublicInstructionDataEncoder(): FixedSizeEncoder<TradePublicInstructionDataArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['usdcAmount', getU64Encoder()],
			['isBuyYes', getBooleanEncoder()],
		]),
		(value) => ({ ...value, discriminator: TRADE_PUBLIC_DISCRIMINATOR }),
	);
}

export function getTradePublicInstructionDataDecoder(): FixedSizeDecoder<TradePublicInstructionData> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['usdcAmount', getU64Decoder()],
		['isBuyYes', getBooleanDecoder()],
	]);
}

export function getTradePublicInstructionDataCodec(): FixedSizeCodec<
	TradePublicInstructionDataArgs,
	TradePublicInstructionData
> {
	return combineCodec(
		getTradePublicInstructionDataEncoder(),
		getTradePublicInstructionDataDecoder(),
	);
}

export type TradePublicInput<
	TAccountTrader extends string = string,
	TAccountMarket extends string = string,
> = {
	trader: TransactionSigner<TAccountTrader>;
	market: Address<TAccountMarket>;
	usdcAmount: TradePublicInstructionDataArgs['usdcAmount'];
	isBuyYes: TradePublicInstructionDataArgs['isBuyYes'];
};

export function getTradePublicInstruction<
	TAccountTrader extends string,
	TAccountMarket extends string,
	TProgramAddress extends Address = typeof PYTHIA_OP_PROGRAM_ADDRESS,
>(
	input: TradePublicInput<TAccountTrader, TAccountMarket>,
	config?: { programAddress?: TProgramAddress },
): TradePublicInstruction<TProgramAddress, TAccountTrader, TAccountMarket> {
	// Program address.
	const programAddress = config?.programAddress ?? PYTHIA_OP_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		trader: { value: input.trader ?? null, isWritable: true },
		market: { value: input.market ?? null, isWritable: true },
	};
	const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

	// Original args.
	const args = { ...input };

	const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
	return Object.freeze({
		accounts: [getAccountMeta(accounts.trader), getAccountMeta(accounts.market)],
		data: getTradePublicInstructionDataEncoder().encode(args as TradePublicInstructionDataArgs),
		programAddress,
	} as TradePublicInstruction<TProgramAddress, TAccountTrader, TAccountMarket>);
}

export type ParsedTradePublicInstruction<
	TProgram extends string = typeof PYTHIA_OP_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		trader: TAccountMetas[0];
		market: TAccountMetas[1];
	};
	data: TradePublicInstructionData;
};

export function parseTradePublicInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>,
): ParsedTradePublicInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 2) {
		// TODO: Coded error.
		throw new Error('Not enough accounts');
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: { trader: getNextAccount(), market: getNextAccount() },
		data: getTradePublicInstructionDataDecoder().decode(instruction.data),
	};
}
