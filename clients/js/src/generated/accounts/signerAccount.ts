/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	transformEncoder,
	type Account,
	type Address,
	type EncodedAccount,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array,
} from '@solana/kit';

export const SIGNER_ACCOUNT_DISCRIMINATOR = new Uint8Array([127, 212, 7, 180, 17, 50, 249, 193]);

export function getSignerAccountDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(SIGNER_ACCOUNT_DISCRIMINATOR);
}

export type SignerAccount = { discriminator: ReadonlyUint8Array; bump: number };

export type SignerAccountArgs = { bump: number };

export function getSignerAccountEncoder(): FixedSizeEncoder<SignerAccountArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['bump', getU8Encoder()],
		]),
		(value) => ({ ...value, discriminator: SIGNER_ACCOUNT_DISCRIMINATOR }),
	);
}

export function getSignerAccountDecoder(): FixedSizeDecoder<SignerAccount> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['bump', getU8Decoder()],
	]);
}

export function getSignerAccountCodec(): FixedSizeCodec<SignerAccountArgs, SignerAccount> {
	return combineCodec(getSignerAccountEncoder(), getSignerAccountDecoder());
}

export function decodeSignerAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>,
): Account<SignerAccount, TAddress>;
export function decodeSignerAccount<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<SignerAccount, TAddress>;
export function decodeSignerAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<SignerAccount, TAddress> | MaybeAccount<SignerAccount, TAddress> {
	return decodeAccount(
		encodedAccount as MaybeEncodedAccount<TAddress>,
		getSignerAccountDecoder(),
	);
}

export async function fetchSignerAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<Account<SignerAccount, TAddress>> {
	const maybeAccount = await fetchMaybeSignerAccount(rpc, address, config);
	assertAccountExists(maybeAccount);
	return maybeAccount;
}

export async function fetchMaybeSignerAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<MaybeAccount<SignerAccount, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config);
	return decodeSignerAccount(maybeAccount);
}

export async function fetchAllSignerAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<Account<SignerAccount>[]> {
	const maybeAccounts = await fetchAllMaybeSignerAccount(rpc, addresses, config);
	assertAccountsExist(maybeAccounts);
	return maybeAccounts;
}

export async function fetchAllMaybeSignerAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<MaybeAccount<SignerAccount>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
	return maybeAccounts.map((maybeAccount) => decodeSignerAccount(maybeAccount));
}

export function getSignerAccountSize(): number {
	return 9;
}
