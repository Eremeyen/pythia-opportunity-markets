/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getArrayDecoder,
	getArrayEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	getU128Decoder,
	getU128Encoder,
	getU8Decoder,
	getU8Encoder,
	transformEncoder,
	type Account,
	type Address,
	type Codec,
	type Decoder,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array,
} from '@solana/kit';
import {
	getCloseRecordDecoder,
	getCloseRecordEncoder,
	type CloseRecord,
	type CloseRecordArgs,
} from '../types';

export const USER_POSITION_DISCRIMINATOR = new Uint8Array([251, 248, 209, 245, 83, 234, 17, 27]);

export function getUserPositionDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(USER_POSITION_DISCRIMINATOR);
}

export type UserPosition = {
	discriminator: ReadonlyUint8Array;
	bump: number;
	user: Address;
	market: Address;
	/** Encrypted user position: [yes_tokens, no_tokens, yes_tokens_closed, no_tokens_closed] as 32-byte ciphertexts */
	positionState: Array<ReadonlyUint8Array>;
	nonce: bigint;
	/** Track position close events for public window reveal */
	closeRecords: Array<CloseRecord>;
};

export type UserPositionArgs = {
	bump: number;
	user: Address;
	market: Address;
	/** Encrypted user position: [yes_tokens, no_tokens, yes_tokens_closed, no_tokens_closed] as 32-byte ciphertexts */
	positionState: Array<ReadonlyUint8Array>;
	nonce: number | bigint;
	/** Track position close events for public window reveal */
	closeRecords: Array<CloseRecordArgs>;
};

export function getUserPositionEncoder(): Encoder<UserPositionArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['bump', getU8Encoder()],
			['user', getAddressEncoder()],
			['market', getAddressEncoder()],
			['positionState', getArrayEncoder(fixEncoderSize(getBytesEncoder(), 32), { size: 4 })],
			['nonce', getU128Encoder()],
			['closeRecords', getArrayEncoder(getCloseRecordEncoder())],
		]),
		(value) => ({ ...value, discriminator: USER_POSITION_DISCRIMINATOR }),
	);
}

export function getUserPositionDecoder(): Decoder<UserPosition> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['bump', getU8Decoder()],
		['user', getAddressDecoder()],
		['market', getAddressDecoder()],
		['positionState', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: 4 })],
		['nonce', getU128Decoder()],
		['closeRecords', getArrayDecoder(getCloseRecordDecoder())],
	]);
}

export function getUserPositionCodec(): Codec<UserPositionArgs, UserPosition> {
	return combineCodec(getUserPositionEncoder(), getUserPositionDecoder());
}

export function decodeUserPosition<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>,
): Account<UserPosition, TAddress>;
export function decodeUserPosition<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<UserPosition, TAddress>;
export function decodeUserPosition<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<UserPosition, TAddress> | MaybeAccount<UserPosition, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getUserPositionDecoder());
}

export async function fetchUserPosition<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<Account<UserPosition, TAddress>> {
	const maybeAccount = await fetchMaybeUserPosition(rpc, address, config);
	assertAccountExists(maybeAccount);
	return maybeAccount;
}

export async function fetchMaybeUserPosition<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<MaybeAccount<UserPosition, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config);
	return decodeUserPosition(maybeAccount);
}

export async function fetchAllUserPosition(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<Account<UserPosition>[]> {
	const maybeAccounts = await fetchAllMaybeUserPosition(rpc, addresses, config);
	assertAccountsExist(maybeAccounts);
	return maybeAccounts;
}

export async function fetchAllMaybeUserPosition(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<MaybeAccount<UserPosition>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
	return maybeAccounts.map((maybeAccount) => decodeUserPosition(maybeAccount));
}
