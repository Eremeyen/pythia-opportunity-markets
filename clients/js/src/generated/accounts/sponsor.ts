/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	addDecoderSizePrefix,
	addEncoderSizePrefix,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getBooleanDecoder,
	getBooleanEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getI64Decoder,
	getI64Encoder,
	getStructDecoder,
	getStructEncoder,
	getU32Decoder,
	getU32Encoder,
	getU64Decoder,
	getU64Encoder,
	getU8Decoder,
	getU8Encoder,
	getUtf8Decoder,
	getUtf8Encoder,
	transformEncoder,
	type Account,
	type Address,
	type Codec,
	type Decoder,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array,
} from '@solana/kit';

export const SPONSOR_DISCRIMINATOR = new Uint8Array([19, 128, 115, 109, 118, 109, 66, 213]);

export function getSponsorDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(SPONSOR_DISCRIMINATOR);
}

export type Sponsor = {
	discriminator: ReadonlyUint8Array;
	bump: number;
	authority: Address;
	name: string;
	isWhitelisted: boolean;
	creationDate: bigint;
	totalMarketsCreated: bigint;
};

export type SponsorArgs = {
	bump: number;
	authority: Address;
	name: string;
	isWhitelisted: boolean;
	creationDate: number | bigint;
	totalMarketsCreated: number | bigint;
};

export function getSponsorEncoder(): Encoder<SponsorArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['bump', getU8Encoder()],
			['authority', getAddressEncoder()],
			['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
			['isWhitelisted', getBooleanEncoder()],
			['creationDate', getI64Encoder()],
			['totalMarketsCreated', getU64Encoder()],
		]),
		(value) => ({ ...value, discriminator: SPONSOR_DISCRIMINATOR }),
	);
}

export function getSponsorDecoder(): Decoder<Sponsor> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['bump', getU8Decoder()],
		['authority', getAddressDecoder()],
		['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
		['isWhitelisted', getBooleanDecoder()],
		['creationDate', getI64Decoder()],
		['totalMarketsCreated', getU64Decoder()],
	]);
}

export function getSponsorCodec(): Codec<SponsorArgs, Sponsor> {
	return combineCodec(getSponsorEncoder(), getSponsorDecoder());
}

export function decodeSponsor<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>,
): Account<Sponsor, TAddress>;
export function decodeSponsor<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Sponsor, TAddress>;
export function decodeSponsor<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Sponsor, TAddress> | MaybeAccount<Sponsor, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getSponsorDecoder());
}

export async function fetchSponsor<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<Account<Sponsor, TAddress>> {
	const maybeAccount = await fetchMaybeSponsor(rpc, address, config);
	assertAccountExists(maybeAccount);
	return maybeAccount;
}

export async function fetchMaybeSponsor<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<MaybeAccount<Sponsor, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config);
	return decodeSponsor(maybeAccount);
}

export async function fetchAllSponsor(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<Account<Sponsor>[]> {
	const maybeAccounts = await fetchAllMaybeSponsor(rpc, addresses, config);
	assertAccountsExist(maybeAccounts);
	return maybeAccounts;
}

export async function fetchAllMaybeSponsor(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<MaybeAccount<Sponsor>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
	return maybeAccounts.map((maybeAccount) => decodeSponsor(maybeAccount));
}
