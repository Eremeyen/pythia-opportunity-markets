/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	addDecoderSizePrefix,
	addEncoderSizePrefix,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getArrayDecoder,
	getArrayEncoder,
	getBooleanDecoder,
	getBooleanEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getI64Decoder,
	getI64Encoder,
	getOptionDecoder,
	getOptionEncoder,
	getStructDecoder,
	getStructEncoder,
	getU128Decoder,
	getU128Encoder,
	getU32Decoder,
	getU32Encoder,
	getU64Decoder,
	getU64Encoder,
	getU8Decoder,
	getU8Encoder,
	getUtf8Decoder,
	getUtf8Encoder,
	transformEncoder,
	type Account,
	type Address,
	type Codec,
	type Decoder,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type Option,
	type OptionOrNullable,
	type ReadonlyUint8Array,
} from '@solana/kit';
import {
	getMarketWindowDecoder,
	getMarketWindowEncoder,
	type MarketWindow,
	type MarketWindowArgs,
} from '../types';

export const MARKET_DISCRIMINATOR = new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154]);

export function getMarketDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(MARKET_DISCRIMINATOR);
}

export type Market = {
	discriminator: ReadonlyUint8Array;
	bump: number;
	sponsor: Address;
	authority: Address;
	question: string;
	resolutionDate: bigint;
	windowState: MarketWindow;
	liquidityCap: bigint;
	initialLiquidityUsdc: bigint;
	/** Encrypted market state: [yes_pool, no_pool, k, total_trades] as 32-byte ciphertexts */
	marketState: Array<ReadonlyUint8Array>;
	publicYesPool: bigint;
	publicNoPool: bigint;
	publicYesPrice: bigint;
	publicNoPrice: bigint;
	publicTotalTrades: bigint;
	nonce: bigint;
	oppWindowDuration: bigint;
	pubWindowDuration: bigint;
	lastSwitchTs: bigint;
	resolved: boolean;
	outcome: Option<boolean>;
};

export type MarketArgs = {
	bump: number;
	sponsor: Address;
	authority: Address;
	question: string;
	resolutionDate: number | bigint;
	windowState: MarketWindowArgs;
	liquidityCap: number | bigint;
	initialLiquidityUsdc: number | bigint;
	/** Encrypted market state: [yes_pool, no_pool, k, total_trades] as 32-byte ciphertexts */
	marketState: Array<ReadonlyUint8Array>;
	publicYesPool: number | bigint;
	publicNoPool: number | bigint;
	publicYesPrice: number | bigint;
	publicNoPrice: number | bigint;
	publicTotalTrades: number | bigint;
	nonce: number | bigint;
	oppWindowDuration: number | bigint;
	pubWindowDuration: number | bigint;
	lastSwitchTs: number | bigint;
	resolved: boolean;
	outcome: OptionOrNullable<boolean>;
};

export function getMarketEncoder(): Encoder<MarketArgs> {
	return transformEncoder(
		getStructEncoder([
			['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
			['bump', getU8Encoder()],
			['sponsor', getAddressEncoder()],
			['authority', getAddressEncoder()],
			['question', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
			['resolutionDate', getI64Encoder()],
			['windowState', getMarketWindowEncoder()],
			['liquidityCap', getU64Encoder()],
			['initialLiquidityUsdc', getU64Encoder()],
			['marketState', getArrayEncoder(fixEncoderSize(getBytesEncoder(), 32), { size: 4 })],
			['publicYesPool', getU64Encoder()],
			['publicNoPool', getU64Encoder()],
			['publicYesPrice', getU64Encoder()],
			['publicNoPrice', getU64Encoder()],
			['publicTotalTrades', getU64Encoder()],
			['nonce', getU128Encoder()],
			['oppWindowDuration', getU64Encoder()],
			['pubWindowDuration', getU64Encoder()],
			['lastSwitchTs', getI64Encoder()],
			['resolved', getBooleanEncoder()],
			['outcome', getOptionEncoder(getBooleanEncoder())],
		]),
		(value) => ({ ...value, discriminator: MARKET_DISCRIMINATOR }),
	);
}

export function getMarketDecoder(): Decoder<Market> {
	return getStructDecoder([
		['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
		['bump', getU8Decoder()],
		['sponsor', getAddressDecoder()],
		['authority', getAddressDecoder()],
		['question', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
		['resolutionDate', getI64Decoder()],
		['windowState', getMarketWindowDecoder()],
		['liquidityCap', getU64Decoder()],
		['initialLiquidityUsdc', getU64Decoder()],
		['marketState', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: 4 })],
		['publicYesPool', getU64Decoder()],
		['publicNoPool', getU64Decoder()],
		['publicYesPrice', getU64Decoder()],
		['publicNoPrice', getU64Decoder()],
		['publicTotalTrades', getU64Decoder()],
		['nonce', getU128Decoder()],
		['oppWindowDuration', getU64Decoder()],
		['pubWindowDuration', getU64Decoder()],
		['lastSwitchTs', getI64Decoder()],
		['resolved', getBooleanDecoder()],
		['outcome', getOptionDecoder(getBooleanDecoder())],
	]);
}

export function getMarketCodec(): Codec<MarketArgs, Market> {
	return combineCodec(getMarketEncoder(), getMarketDecoder());
}

export function decodeMarket<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>,
): Account<Market, TAddress>;
export function decodeMarket<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Market, TAddress>;
export function decodeMarket<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Market, TAddress> | MaybeAccount<Market, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getMarketDecoder());
}

export async function fetchMarket<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<Account<Market, TAddress>> {
	const maybeAccount = await fetchMaybeMarket(rpc, address, config);
	assertAccountExists(maybeAccount);
	return maybeAccount;
}

export async function fetchMaybeMarket<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig,
): Promise<MaybeAccount<Market, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config);
	return decodeMarket(maybeAccount);
}

export async function fetchAllMarket(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<Account<Market>[]> {
	const maybeAccounts = await fetchAllMaybeMarket(rpc, addresses, config);
	assertAccountsExist(maybeAccounts);
	return maybeAccounts;
}

export async function fetchAllMaybeMarket(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig,
): Promise<MaybeAccount<Market>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
	return maybeAccounts.map((maybeAccount) => decodeMarket(maybeAccount));
}
